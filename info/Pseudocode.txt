public class ArrayMysterySolver {

    void solveArrayMystery() {
        Gui gui = getLinkToGui();
        gui.constructArrayOnScreen(array size, "array"); // assuming the gui has a method that will construct the screen
        ForLoopHeader loop = gui.getForLoopHeader(); // this will search the code and parse it for the parts it needs, like initialization etc.
        // if we want hte students to do this too, it could be made interactive, like asking them
        // what the start, end, update, and loop test were

        gui.placeBox(loop.initialIValue, "iBox"); // uses gui to place a box on the user's screen
        gui.placeBox(gui.getArrayLength(), "lengthBox");
        while (loop.evaluateLoopCondition(gui.getValue("iBox"))) {
            loopContents = parseLoopContents();
            for each (assignmentStatement at start of loopContents) {
                updateSingleValueInArray(assignmentStatement); // see method below
            }
            if (there is an if/else branch) {
                Expression if_test = gui.getIfTest(); // assuming the gui can parse the code
                boolean should_enter_if = computeExpressionInvolvingArray(if_test); // see below
                if (should_enter_if) {
                    for each (assignmentStatement in the if branch) {
                        updateSingleValueInArray(assignmentStatement);
                    }
                } else if (there is an else branch) {
                    for each (assignmentStatement in the else branch) {
                        updateSingleValueInArray(assignmentStatement);
                    }
                }
            }
            for each (assignmentStatement after the if/else branch) {
                updateSingleValueInArray(assignmentStatement);
            }
            int update = loop.getUpdate();
            int current_val_of_i = gui.getValue("iBox");
            gui.updateBox("iBox", update + current_val_of_i);
        }

    }

    /**
     * Given an assignment statement (not sure what the type
     * of that will be yet), it evaluates the right hand
     * side and reassigns the element of the array that is
     * on the left hand side
     */
    void updateSingleValueInArray(assignmentStatement) {
        RHS = assignmentStatement.getRightHandSide(); // assuming assignment statement has a way to get the left hand side
        int val = computeExpressionInvolvingArray(RHS);
        LHS = assignmentStatement.getLeftHandSide(); // assuming assignment statement has a way to get the left hand side
        gui.updateValue(LHS.arrayElement, newVal); // uses gui's method to update the value on the screen

    }

    /**
     * Given an expression involving array elements,
     * it locates the values of the those elements
     * on the user's screen, and then uses those
     * numeric values to evaluate the expression
     */
    Type computeExpressionInvolvingArray(expression) {
        Map<ArrayElement, Integer> map = new HashMap<Element, Integer>();
        for (element in expression) {
            int val;
            if (element is an array element) {
                val = gui.findBoxInArray(element's value of i, "array"); // finds the box on the screen corresponding to this value of i
            } else if (element is a variable in the variable box) {
                val = gui.findBoxInVariableBank(element); // assuming there is a variable bank on the user's screen
            } else { // must be a constant
                val = element;
            }
            map.put(array_element, val);
        }
        Map<ArrayElement, Integer> map = mapElementsToValues(RHS);
        return evaluateExpression(RHS, map); // this method will be using the expression team's code
    }
}

