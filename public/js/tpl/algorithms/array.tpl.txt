function TPLAlgorithm() {
    // types:
    // AstNode: a java ast node
    // Line: a java ast node, but we want to highlight the line rather than the node
    // VariableBank: the bank of all local variables
    // Variable: a value that will be added to the variable bank, of form {name:string, type:string, value:*}.

    // FIXME get this out of here once simulator can pass input parameters
    let ast;
    [no_step]
    ast = state.ast;

    [no_step]
    state.vars = helper.copy_args(state.args);

    let variables: VariableBank;
    [no_step]
    variables = helper.create_new_variable_bank();

    [no_step]
    {
        [prompt]
        "First, look at the method call.";

        let this_is_the_parameter: Parameter;
        this_is_the_parameter = helper.get_parameter(state.args);

        helper.add_this_to_the_variable_bank(variables, this_is_the_parameter);
    }

    // FIXME get this out of here once simulator handles refs correctly
    let loop;
    [no_step]
    loop = helper.get_loop(ast);

    [no_step]
    {
        [prompt]
        "Next, look at the loop header.";

        let this_is_the_loop_initializer: AstNode;
        this_is_the_loop_initializer = loop.initializer;

        let add_this_to_the_variable_bank:Variable;
        add_this_to_the_variable_bank = helper.add_this_to_the_variable_bank(variables, helper.get_loop_init_variable(variables, this_is_the_loop_initializer));
    }

    let this_is_the_loop_condition: AstNode;
    this_is_the_loop_condition = loop.condition;

    let this_is_the_loop_increment: AstNode;
    this_is_the_loop_increment = loop.increment;

    while (helper.does_the_loop_condition_hold(variables, this_is_the_loop_condition)) {
        let this_is_the_next_line_to_execute: Line;
        [no_step]
        this_is_the_next_line_to_execute = null;

        do {
            this_is_the_next_line_to_execute = helper.get_the_next_loop_body_line_to_execute(loop, this_is_the_next_line_to_execute);
            helper.execute_statement(variables, this_is_the_next_line_to_execute);

            let this_is_the_expression_result: Variable;

            [no_step]
            {
                // FIXME assume it's an assignment statement
                // copy expression to workspace
                let this_is_the_expression: Expression;
                this_is_the_expression = helper.copy(this_is_the_next_line_to_execute.expression.args[1]);

                // for each array lookup in the expression, do the array lookup
                for (let this_is_the_array_lookup: IndexExpression of helper.all_array_lookups_in_the_expression(this_is_the_expression)) {
                    // evaluate this node of the ast down to a literal
                    let this_is_the_index: Index;
                    this_is_the_index = this_is_the_array_lookup.index;
                    helper.evaluate_this_expression(variables, this_is_the_index);

                    let this_is_the_array: Variable;
                    this_is_the_array = helper.evaluate_this_expression2(variables, this_is_the_array_lookup.object);

                    helper.do_the_array_lookup(this_is_the_array, this_is_the_index, this_is_the_array_lookup);
                }

                // evalute the rest of the expression
                this_is_the_expression_result = helper.evaluate_this_expression2(variables, this_is_the_expression);
            }

            // for the array being assigned to, lookup the box
            let this_is_the_assigner;
            this_is_the_assigner = helper.copy(this_is_the_next_line_to_execute.expression.args[0]);

            let this_is_the_index: Index;
            this_is_the_index = this_is_the_assigner.index;
            helper.evaluate_this_expression(variables, this_is_the_index);

            let this_is_the_array: Variable;
            this_is_the_array = helper.evaluate_this_expression2(variables, this_is_the_assigner.object);

            // assign the new value to the box
            helper.assign_the_new_value_to_the_array_element(this_is_the_array, this_is_the_index, this_is_the_expression_result);

        } while (helper.is_there_another_line_to_execute(ast, this_is_the_next_line_to_execute));

        helper.execute_the_loop_increment(variables, this_is_the_loop_increment);
    }

    [no_step]
    state.answer = helper.calculate_answer(variables);

    [prompt]
    "Write the answer in the box.";
}
